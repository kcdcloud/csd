## List commands
```
rsync
grep
awk
sed
sort
xargs
md5sum
gpg
curl
wget
apache
mysql
python
php
gcc
tar
emacs
diff
patch
```
**Path file linux ubuntu on windows**
>C:\Users\Kirkland\AppData\Local\Lxss\rootfs\

утилиты
```
sysbench
byobu
screen 
tty и vt100
```
посмотреть shell
```
echo $SHELL
``` 
выйти из оболочки (exit или ctrl+D) или закончить сеанс (logout)
**Пути cd**
Относительные пути НИКОГДА не начинаются с "/"
```
cd local/bin
cd .. // подняться на один каталог вверх
$ pwd
/usr/local
$ cd ../share
$ pwd
/usr/share
```
 "." означает «текущая директория» не используется с командой cd, но часто используется для выполнения программы из текущей директории
```
./myprog
./myprog ~/myfile.txt // запустить прогграмму из текущей директории и открыть в ней файл из домашней директории текущего пользователя
./myprog ~john/fredsfile.txt // запустить прогграмму из текущей директории и открыть в ней файл из домашней директории пользователя john
```
**Просмотр директорий и файлов ls**
Каждому объекту файловой системы назначен уникальный индекс, называемый номером инода.
```
ls -la
```
"a" отоброжает скрытые файлы и папки "l" выводит дополнительную информацию колонка 1 показывает права доступа колонка 2 содержит числа ссылок колонка 3 и 4 список владельцев и групп колонка 5 размер объекта колонка 6 время последнего изменения. Если файлы являются символическими ссылками, то вы увидите стрелку -> и путь, куда указывает эта символическая ссылка.
option
-R - рекурсивный просмотр
-d - просмотр конкретной директории
-i - просмотор номер инода

Для поиска файлов, являющихся символическими ссылками на определенный файл, используйте команду find с опцией -lname
```
find lpi104-6 research/lpi104-6 -lname "*file1"
```
Для поиска файлов, являющихся жесткими ссылками на определенный inode, можно использовать команду find с опцией -samefile и именем файла или с опцией -inum и номером inode
```
find lpi104-6 -samefile lpi104-6/file1
find lpi104-6 -inum 1680103
```
Номер инода у перемещаемого файла остается прежним до тех пор, пока файл назначения находится в той же файловой системе.

**создание директорий mkdir**
-p говорит mkdir создавать любые отсутствующие родительские директории
```
mkdir -p easy/as/pie
man mkdir
```
**создание файлов touch cp mv echo и cat**
```
touch copyme.txt
echo "firstfile" > copyme.txt
cp copyme.txt copiedme.txt
ls -i copyme.txt copiedme.txt
mv copiedme.txt movedme.txt
ls -i movedme.txt
mv /var/tmp/movedme.txt /var/tmp/copyme.txt ~
```
echo принимает аргументы и печатает их на стандартный вывод
Чтобы вывести содержимое файла на терминал, используется команда cat

**Жесткие ссылки**
Новые жесткие ссылки можно создать воспользовавшись командой ln
```
cd /tmp
touch firstlink
ln firstlink secondlink
ls -i firstlink secondlink
```
для жестких ссылок есть несколько ограничений
- можно создавать жесткие ссылки только на файлы, не на директории
- нельзя связать ими несколько файловых систем (Это значит, что у вас не получится создать жесткую ссылку с /usr/bin/bash на /bin/bash и если ваши директории / и /usr находятся в разных файловых системах)

**Символьные ссылки ln -s**
Симлинки — это файлы особого типа, которые ссылаются на другие файлы по имени, а не прямо по номеру инода. Они не спасают файлы от удаления; если файл, на который указывает ссылка, исчезает, то симлинк перестает работать, ломается.
```
ln -s secondlink thirdlink
ls -l firstlink secondlink thirdlink
```
можно создавать символьные ссылки на любой объект файловой системы, включая директории. И благодаря тому, что их реализация основана на путях (не инодах), можно совершенно свободно создать символьную ссылку указывающую на объект другой файловой системы.
```
// вариант 1
ln -s /usr/local/bin bin1
ls -l bin1
// авриант 2
ln -s ../usr/local/bin bin2
ls -l bin2
```
если наша вторая символьная ссылка когда-нибудь будет перемещена в другую директорию, то она может «поломаться» из-за относительности пути
**Удаление файлов rm**
Опция -i сообщает rm удалять файлы в интерактивном режиме — это значит спрашивать перед удалением любого файла. 
```
rm -i file1 file2
```
добавить строку в ваш файл ~/.bashrc, и затем выйти (logout) и войти (login) в систему вновь
```
alias rm="rm -i"
```
Таким образом, rm будет всегда работать в интерактивном режиме
**Удаление папок rmdir**

```
// «способ удаления директорий для лохов»
mkdir mydir
touch mydir/file1
rm mydir/file1
rmdir mydir
// способ 2
rm -rf mydir
```
**Glob-подстановки использование джокеров (wild cards) *, [] и ?**
```
rm file[1-8]
rm file*
ls -d /etc/g*
```
*неподходящие шаблоны*
```
ls -d /usr/bin/asdf*jkl
```
Конструкция [!] эквивалентна конструкции [], за исключением того, что вместо совпадения с символами внутри скобок, она удовлетворяет любому символу, который НЕ перечислен между [! и ]. 
```
rm myfile[!9]
```
удалит все файлы с названием myfile плюс один символ, кроме myfile9
**Предостирежения о джокерах**
```
echo [fo]* > /tmp/mynewfile.txt  // Если шаблон [fo]* совпадет с какими-либо файлами в текущей рабочей директории, то вы обнаружите их имена внутри /tmp/mynewfile.txt, вместо ожидаемого [fo]*.
echo '[fo]*' > /tmp/mynewfile.txt
echo \[fo\]\* > /tmp/mynewfile.txt
```
Оба подхода (одиночные кавычки и экранирующая обратная косая черта) работают с одинаковым эффектом.
Получить больше информации о раскрытии джокеров можно набрав man 7 glob. Чтобы получить больше информации о кавычках в bash, наберите man 1 bash и прочитайте раздел под названием QUOTING.
